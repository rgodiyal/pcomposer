<?php

function readComposerJson($path = 'composer.json') {
    $fullPath = realpath($path);
    echo "Working dir: " . getcwd() . "\n";

    if (!$fullPath || !file_exists($fullPath)) {
        echo "Error: composer.json not found at $path\n";
        exit(1);
    }

    $content = file_get_contents($fullPath);
    $json = json_decode($content, true);

    if (json_last_error() !== JSON_ERROR_NONE) {
        echo "Error: Invalid JSON in composer.json\n";
        exit(1);
    }

    return $json['require'] ?? [];
}

function fetchPackageVersions($packageName) {
    $url = "https://repo.packagist.org/p2/{$packageName}.json";
    $response = @file_get_contents($url);

    if ($response === false) {
        echo "Failed to fetch: $packageName\n";
        return [];
    }

    $data = json_decode($response, true);
    if (!isset($data['packages'][$packageName])) {
        echo "Invalid package data for: $packageName\n";
        return [];
    }

    return array_column($data['packages'][$packageName], 'version');
}

function fetchPackageDistUrl($packageName, $version) {
    $url = "https://repo.packagist.org/p2/{$packageName}.json";
    $response = @file_get_contents($url);

    if ($response === false) {
        echo "Failed to fetch data for: $packageName\n";
        return null;
    }

    $data = json_decode($response, true);
    if (!isset($data['packages'][$packageName])) {
        echo "Invalid package data for: $packageName\n";
        return null;
    }

    foreach ($data['packages'][$packageName] as $pkg) {
        if ($pkg['version'] === $version) {
            return $pkg['dist']['url'] ?? null;  // Get ZIP URL from dist
        }
    }

    return null;  // Version not found
}

function downloadAndExtractZip(string $url, string $destinationFolder): void {
    $tempFile = tempnam(sys_get_temp_dir(), 'pcomposer_');

    // Set User-Agent to avoid 403 error from GitHub
    $opts = [
        "http" => [
            "header" => "User-Agent: pcomposer/1.0\r\n"
        ]
    ];
    $context = stream_context_create($opts);

    echo "  üì• Downloading ZIP...\n";
    $data = file_get_contents($url, false, $context);
    if (!$data) {
        echo "  ‚ùå Failed to download ZIP file.\n";
        return;
    }

    file_put_contents($tempFile, $data);

    // Extract ZIP to temp folder
    $tempDir = $destinationFolder . '_temp';
    if (!is_dir($tempDir)) {
        mkdir($tempDir, 0777, true);
    }

    $zip = new ZipArchive;
    if ($zip->open($tempFile) === TRUE) {
        $zip->extractTo($tempDir);
        $zip->close();
    } else {
        echo "  ‚ùå Failed to extract ZIP.\n";
        return;
    }

    // Find extracted top-level folder
    $entries = array_diff(scandir($tempDir), ['.', '..']);
    $extractedFolderName = reset($entries); // first entry (e.g., Seldaek-monolog-xyz)
    $sourcePath = "$tempDir/$extractedFolderName";

    // Prepare final destination
    if (!is_dir($destinationFolder)) {
        mkdir($destinationFolder, 0777, true);
    }

    // Move src/ or all contents
    $srcDir = "$sourcePath/src";
    if (is_dir($srcDir)) {
        $target = "$destinationFolder/src";
        if (!is_dir($target)) {
            rename($srcDir, $target);
        }
    } else {
        // Copy all contents if no src/
        recurseCopy($sourcePath, $destinationFolder);
    }

    // Cleanup
    rrmdir($tempDir);
    unlink($tempFile);

    echo "  ‚úÖ Extracted to $destinationFolder\n";
}

// Helper: Recursively copy directory
function recurseCopy($src, $dst) {
    $dir = opendir($src);
    @mkdir($dst);
    while (($file = readdir($dir)) !== false) {
        if ($file === '.' || $file === '..') continue;
        $srcPath = "$src/$file";
        $dstPath = "$dst/$file";
        if (is_dir($srcPath)) {
            recurseCopy($srcPath, $dstPath);
        } else {
            copy($srcPath, $dstPath);
        }
    }
    closedir($dir);
}

// Helper: Recursively remove directory
function rrmdir($dir) {
    if (!is_dir($dir)) return;
    foreach (scandir($dir) as $file) {
        if ($file === '.' || $file === '..') continue;
        $path = "$dir/$file";
        is_dir($path) ? rrmdir($path) : unlink($path);
    }
    rmdir($dir);
}

function generateAutoloader($vendorDir = 'vendor') {
    $autoloadPath = $vendorDir . '/autoload.php';
    $autoloadCode = "<?php\n\n";
    $autoloadCode .= "// Auto-generated by pcomposer\n\n";

    $psr4Map = [];

    foreach (glob($vendorDir . '/*', GLOB_ONLYDIR) as $packageDir) {
        $composerJsonPath = $packageDir . '/composer.json';
        if (!file_exists($composerJsonPath)) continue;

        $json = json_decode(file_get_contents($composerJsonPath), true);
        if (!isset($json['autoload']['psr-4'])) continue;

        echo "Found PSR-4 autoload for: " . $packageDir . "\n"; // Debugging output

        foreach ($json['autoload']['psr-4'] as $namespace => $path) {
            $fullPath = $packageDir . '/' . rtrim($path, '/');
            $psr4Map[$namespace] = realpath($fullPath); // Ensure we get the absolute path
        }
    }

    if (empty($psr4Map)) {
        echo "No PSR-4 mappings found!\n"; // Debugging output
    }

    // Generate PSR-4 loader
    $autoloadCode .= "spl_autoload_register(function (\$class) {\n";
    $autoloadCode .= "    \$prefixes = [\n";

    foreach ($psr4Map as $ns => $dir) {
        $autoloadCode .= "        " . var_export($ns, true) . " => __DIR__ . '/" . str_replace('\\', '/', substr($dir, strlen($vendorDir) + 1)) . "',\n";
    }

    $autoloadCode .= "    ];\n\n";
    $autoloadCode .= "    foreach (\$prefixes as \$prefix => \$baseDir) {\n";
    $autoloadCode .= "        if (str_starts_with(\$class, \$prefix)) {\n";
    $autoloadCode .= "            \$relativeClass = substr(\$class, strlen(\$prefix));\n";
    $autoloadCode .= "            \$file = \$baseDir . '/' . str_replace('\\\\', '/', \$relativeClass) . '.php';\n";
    $autoloadCode .= "            if (file_exists(\$file)) {\n";
    $autoloadCode .= "                require \$file;\n";
    $autoloadCode .= "                return;\n";
    $autoloadCode .= "            }\n";
    $autoloadCode .= "        }\n";
    $autoloadCode .= "    }\n";
    $autoloadCode .= "});\n";

    file_put_contents($autoloadPath, $autoloadCode);
    echo "‚úÖ PSR-4 autoloader generated at $autoloadPath\n";
}

function fetchJson(string $url): ?array {
    $opts = [
        "http" => [
            "header" => "User-Agent: pcomposer/1.0\r\n"
        ]
    ];
    $context = stream_context_create($opts);

    $json = file_get_contents($url, false, $context);
    if ($json === false) return null;

    return json_decode($json, true);
}

function fetchPackageDependencies($packageName, $version) {
    $url = "https://repo.packagist.org/p2/$packageName.json";

    $json = fetchJson($url);
    if (!$json || !isset($json['packages'][$packageName])) {
        return [];
    }

    foreach ($json['packages'][$packageName] as $packageVersion) {
        if ($packageVersion['version'] === $version) {
            return array_filter(
                $packageVersion['require'] ?? [],
                fn($name) => !str_starts_with($name, 'php') && !str_starts_with($name, 'ext-')
            );
        }
    }

    return [];
}

function installPackage($package, $versionConstraint, &$installed = [], &$lockData = []) {
    // Skip installing PHP itself and PHP extensions like ext-*
    if ($package === 'php' || strpos($package, 'ext-') === 0) {
        echo "  ‚ùå Skipping $package (runtime dependency)\n";
        return;
    }

    if (isset($installed[$package])) {
        echo "  ‚ö†Ô∏è Skipping already installed: $package\n";
        return;
    }

    echo "\nüì¶ Installing: $package (Constraint: $versionConstraint)\n";

    $versions = fetchPackageVersions($package);
    if (empty($versions)) {
        echo "  ‚ùå No versions found for $package\n";
        return;
    }

    $version = $versions[0]; // Use latest available version
    $zipUrl = fetchPackageDistUrl($package, $version);
    if (!$zipUrl) {
        echo "  ‚ùå Failed to fetch ZIP URL for $package@$version\n";
        return;
    }

    $destinationFolder = 'vendor/' . str_replace('/', '_', $package);
    downloadAndExtractZip($zipUrl, $destinationFolder);

    // Mark as installed
    $installed[$package] = true;

    // Save to lock data
    $lockData['packages'][$package] = $version;

    // Recursively install dependencies
    $dependencies = fetchPackageDependencies($package, $version);
    foreach ($dependencies as $depName => $depConstraint) {
        installPackage($depName, $depConstraint, $installed, $lockData);
    }
}

function main() {
    global $argv;
    $jsonPath = $argv[1] ?? 'composer.json';

    echo "Reading $jsonPath...\n";
    $packages = readComposerJson($jsonPath);

    $installed = [];
    $lockData = [ "packages" => [] ];

    foreach ($packages as $package => $versionConstraint) {
        installPackage($package, $versionConstraint, $installed, $lockData);
    }

    generateAutoloader();

    file_put_contents('pcomposer.lock', json_encode($lockData, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES));
    echo "‚úÖ Lock file written: pcomposer.lock\n";
    echo "\nüéâ Done! You can now use 'vendor/autoload.php'\n";
}


main();
